<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <title>MES Batch Sender ‚ö° Parallel + Retry + Stop/Pause</title>
  <style>
    body { font-family: Calibri, sans-serif; background:#f7f9fc; margin:0; padding:0; }
    .container {
      max-width: 900px; margin: 30px auto; background: white;
      padding: 25px 30px; border-radius: 14px;
      box-shadow: 0 0 12px rgba(0,0,0,0.1);
    }
    h1 { text-align:center; color:#0057b7; }
    label { font-weight:600; display:block; margin-top:10px; }
    input, textarea, button {
      width:100%; margin:6px 0; padding:10px; border-radius:6px;
      border:1px solid #ccc; font-size:15px;
    }
    textarea { resize:vertical; }
    button {
      background:#0057b7; color:white; border:none; font-weight:bold;
      cursor:pointer; transition:0.3s;
    }
    button:hover { background:#0072ff; }
    #progress { width:100%; background:#e5e5e5; border-radius:5px; margin-top:10px; height:14px; }
    #bar { height:14px; background:linear-gradient(90deg,#00c851,#007e33); width:0%; transition:width 0.3s; }
    pre {
      background:#f0f0f0; padding:10px; border-radius:8px;
      max-height:400px; overflow-y:auto; font-size:13px;
      white-space:pre-wrap;
    }
    .btn-row { display:flex; gap:10px; margin-top:10px; }
    .btn-row button { flex:1; }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö° MES Batch Sender (Parallel + Retry + Pause)</h1>
    <p>G·ª≠i h√†ng lo·∫°t y√™u c·∫ßu MES song song, c√≥ t·ª± ƒë·ªông retry v√† n√∫t t·∫°m d·ª´ng.</p>

    <label>üîπ Package (mxpackage):</label>
    <input id="pkg" placeholder="M_HAR-0207_1_HAR0294RGL001001_01_02">

    <label>üîπ Danh s√°ch (m·ªói d√≤ng: opserial,mcid[,processtype])</label>
    <textarea id="list" rows="8" placeholder="1,M10002390
2,M10002391,FA
3,M10002396,QA"></textarea>

    <label>üîπ Endpoint:</label>
    <input id="endpoint" value="https://mes-system.chiscoong-cloudflare-com.workers.dev/">

    <label>üîπ S·ªë lu·ªìng song song:</label>
    <input id="threads" type="number" min="1" max="20" value="10">

    <div class="btn-row">
      <button id="run">‚ñ∂Ô∏è G·ª≠i h√†ng lo·∫°t</button>
      <button id="pause" style="background:#ffc107">‚è∏Ô∏è T·∫°m d·ª´ng</button>
      <button id="stop" style="background:#dc3545">‚èπÔ∏è D·ª´ng</button>
    </div>

    <div id="progress"><div id="bar"></div></div>

    <h3>üìã Log ti·∫øn tr√¨nh:</h3>
    <pre id="log">Ch∆∞a c√≥ ho·∫°t ƒë·ªông n√†o...</pre>
    <button id="export" style="background:#28a745">üíæ Xu·∫•t k·∫øt qu·∫£ CSV</button>
  </div>

  <script>
  // ‚öôÔ∏è Tr·∫°ng th√°i to√†n c·ª•c
  let isPaused = false;
  let isStopped = false;

  async function sendRequest({endpoint, pkg, opserial, mcid, processtype}) {
    const url = `${endpoint}?mxpackage=${encodeURIComponent(pkg)}&opserial=${opserial}&mcid=${mcid}${processtype ? `&processtype=${processtype}` : ''}`;
    try {
      const res = await fetch(url);
      const text = await res.text();
      const ok = res.ok && /"IsSuccess":\s*true/.test(text);
      return { ok, status: res.status, body: text };
    } catch (err) {
      return { ok: false, error: err.message };
    }
  }

  async function sendWithRetry(task, retries = 3, delay = 1000) {
    for (let attempt = 1; attempt <= retries; attempt++) {
      if (isStopped) return { ok: false, status: "STOPPED", attempt };
      const res = await sendRequest(task);
      if (res.ok) return { ...res, attempt };
      if (attempt < retries) await new Promise(r => setTimeout(r, delay));
    }
    return { ok: false, attempt: retries };
  }

  document.getElementById("pause").onclick = () => {
    isPaused = !isPaused;
    document.getElementById("pause").textContent = isPaused ? "‚ñ∂Ô∏è Ti·∫øp t·ª•c" : "‚è∏Ô∏è T·∫°m d·ª´ng";
  };

  document.getElementById("stop").onclick = () => {
    if (!isStopped) {
      isStopped = true;
      document.getElementById("log").textContent += "\n‚èπÔ∏è ƒê√£ d·ª´ng qu√° tr√¨nh g·ª≠i.\n";
    }
  };

  document.getElementById("run").onclick = async () => {
    isPaused = false;
    isStopped = false;
    document.getElementById("pause").textContent = "‚è∏Ô∏è T·∫°m d·ª´ng";

    const pkg = document.getElementById("pkg").value.trim();
    const lines = document.getElementById("list").value.split("\n").map(x=>x.trim()).filter(Boolean);
    const endpoint = document.getElementById("endpoint").value.trim();
    const threads = parseInt(document.getElementById("threads").value) || 10;
    const log = document.getElementById("log");
    const bar = document.getElementById("bar");
    const total = lines.length;
    let done = 0;
    const results = [];

    if (!pkg) return alert("‚ùó Vui l√≤ng nh·∫≠p package!");
    if (!lines.length) return alert("‚ùó Vui l√≤ng nh·∫≠p danh s√°ch c√¥ng ƒëo·∫°n / m√°y!");

    log.textContent = `‚ö° G·ª≠i ${total} d√≤ng (song song ${threads} lu·ªìng)...\n`;

    const queue = lines.map((line, idx) => {
      const [opserial, mcid, processtype] = line.split(",").map(x=>x.trim());
      return { opserial, mcid, processtype, index: idx + 1 };
    });

    async function worker() {
      while (queue.length > 0 && !isStopped) {
        if (isPaused) {
          await new Promise(r => setTimeout(r, 500)); // ch·ªù khi t·∫°m d·ª´ng
          continue;
        }

        const task = queue.shift();
        if (!task.opserial || !task.mcid) {
          log.textContent += `‚ö†Ô∏è B·ªè qua d√≤ng kh√¥ng h·ª£p l·ªá: "${task}"\n`;
          continue;
        }

        log.textContent += `üöÄ [${task.index}] G·ª≠i ${task.mcid} (op ${task.opserial}${task.processtype?','+task.processtype:''})...\n`;

        const res = await sendWithRetry({ endpoint, pkg, ...task });
        const icon = res.ok ? "‚úÖ" : (res.status === "STOPPED" ? "‚èπÔ∏è" : "‚ùå");
        const retryNote = res.attempt > 1 ? ` üîÅ(${res.attempt} l·∫ßn)` : "";
        log.textContent += `${icon} [${task.index}] ${task.mcid} ‚Üí ${res.status || 'error'}${retryNote}\n`;

        results.push({ ...task, status: res.status || "ERROR", success: res.ok, retries: res.attempt });

        done++;
        bar.style.width = `${(done/total)*100}%`;
      }
    }

    const workers = Array.from({ length: threads }, () => worker());
    await Promise.all(workers);

    if (isStopped) {
      log.textContent += "\n‚èπÔ∏è Qu√° tr√¨nh ƒë√£ d·ª´ng th·ªß c√¥ng.\n";
    } else {
      log.textContent += "\nüéØ Ho√†n t·∫•t to√†n b·ªô.\n";
    }
    window._batchResults = results;
  };

  // üíæ Xu·∫•t CSV
  document.getElementById("export").onclick = () => {
    const data = window._batchResults || [];
    if (!data.length) return alert("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t!");
    const header = "index,opserial,mcid,processtype,status,success,retries\n";
    const rows = data.map(r=>`${r.index},${r.opserial},${r.mcid},${r.processtype||''},${r.status},${r.success},${r.retries}`);
    const blob = new Blob([header + rows.join("\n")], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = "mes_batch_result.csv"; a.click();
  };
  </script>
</body>
</html>
